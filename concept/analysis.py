# This file is part of COùòïCEPT, the cosmological ùòï-body code in Python.
# Copyright ¬© 2015‚Äì2019 Jeppe Mosgaard Dakin.
#
# COùòïCEPT is free software: You can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# COùòïCEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with COùòïCEPT. If not, see http://www.gnu.org/licenses/
#
# The author of COùòïCEPT can be contacted at dakin(at)phys.au.dk
# The latest version of COùòïCEPT is available at
# https://github.com/jmd-dk/concept/



# Import everything from the commons module.
# In the .pyx file, Cython declared variables will also get cimported.
from commons import *

# Cython imports
cimport('from mesh import diff_domain')
cimport('from communication import communicate_domain, get_buffer')
cimport('from graphics import plot_powerspec')
cimport('from mesh import CIC_components2œÜ, fft, slab_decompose')



# Function for computing power spectra of sets of components
@cython.pheader(
    # Arguments
    components=list,
    filename=str,
    # Locals
    W='double',
    a='double',
    any_fluid='bint',
    any_particles='bint',
    column_components=list,
    column_width_normal='Py_ssize_t',
    column_widths=list,
    component='Component',
    component_combination=tuple,
    component_combination_str=str,
    component_combinations=object,  # generator
    component_index='Py_ssize_t',
    component_indices_str=str,
    component_mapping=object,  # OrderedDict
    deconv_ijk='double',
    delimiter=str,
    fill_n_modes='bint',
    fmt=list,
    header=list,
    i='Py_ssize_t',
    index_largest_mode='Py_ssize_t',
    interpolation_quantities=list,
    j='Py_ssize_t',
    j_global='Py_ssize_t',
    k='Py_ssize_t',
    k_bin_index='Py_ssize_t',
    k_magnitude='double',
    k2='Py_ssize_t',
    kR='double',
    ki='Py_ssize_t',
    kj='Py_ssize_t',
    kj2='Py_ssize_t',
    kk='Py_ssize_t',
    longest_name_size='Py_ssize_t',
    max_n_modes='Py_ssize_t',
    nyquist='Py_ssize_t',
    power='double[::1]',
    power_dict=object,  # OrderedDict
    power_jik='double',
    reciprocal_sqrt_deconv_ij='double',
    reciprocal_sqrt_deconv_ijk='double',
    reciprocal_sqrt_deconv_j='double',
    representation=str,
    row_components=list,
    row_headings=list,
    row_œÉ=list,
    save_powerspecs='bint',
    size_i='Py_ssize_t',
    size_j='Py_ssize_t',
    size_k='Py_ssize_t',
    slab='double[:, :, ::1]',
    slab_dict=dict,
    slab_fluid='double[:, :, ::1]',
    slab_fluid_jik='double*',
    slab_particles='double[:, :, ::1]',
    slab_particles_jik='double*',
    spectrum_plural=str,
    symmetry_multiplicity='int',
    topline=list,
    Œ£mass='double',
    œÉ_dict=object,  # OrderedDict
    œÉ_str=str,
    œÜ='double[:, :, ::1]',
    œÜ_dict=dict,
)
def powerspec(components, filename):
    global n_modes_fine
    # Always produce the powerspectrum at the current time
    a = universals.a
    # Ordered dicts storing the power and rms density variation,
    # with the component names as keys.
    power_dict = collections.OrderedDict()
    œÉ_dict = collections.OrderedDict()
    # Generator yielding tuples of all possible combinations
    # of the passed components.
    component_combinations = itertools.chain.from_iterable([itertools.combinations(components, i)
                                                            for i in range(1, len(components) + 1)
                                                            ])
    # Compute power spectrum for each combination of components,
    # if they have been selected for power spectrum compuation
    # (either of 'data' or 'plot') in the powerspec_select parameter.
    save_powerspecs = False
    for component_combination in component_combinations:
        if is_selected(component_combination, powerspec_data_select):
            save_powerspecs = True
        elif not is_selected(component_combination, powerspec_plot_select):
            # Neither dump data or plot for this combination
            continue
        component_combination_str = ', '.join(
            [component.name for component in component_combination]
            )
        if len(component_combination) > 1:
            component_combination_str = f'{{{component_combination_str}}}'
        masterprint(f'Computing power spectrum of {component_combination_str} ...')
        # Grab a designated buffer for the power spectrum
        # of this component, and store it in the power dict.
        power = get_buffer(
            k_bin_centers_size,
            f'powerspec_{component_combination_str}',
            nullify=True,
        )
        power_dict[component_combination] = power
        # We now do the CIC interpolation of the component onto a grid
        # and perform the FFT on this grid. Here the œÜ grid is used.
        # We choose to interpolate the mass of each component onto
        # the grid. For both particle and fluid components, the total
        # mass can be computed by
        # Œ£mass = (a*boxsize)**3*œÅ_bar
        #       = boxsize**3*a**(-3*w_eff)*œ±_bar.
        # Since all particles have the same mass, the mass contribution
        # from a single particle is Œ£mass/component.N. For particles of
        # constant mass, this is exactly component.mass. In general,
        # we have Œ£mass/component.N = a**(-3*w_eff)*component.mass.
        # For fluids, each fluid element contributes to the mass by
        # an amount (a*L_cell)**3*œÅ(x)
        #         = (a*boxsize/component.gridsize)**3*œÅ(x)
        #         = (boxsize/component.gridsize)**3*a**(-3*w_eff)*œ±(x).
        Œ£mass = ‚Ñù[boxsize**3]*np.sum(
            [a**(-3*component.w_eff(a=a))*component.œ±_bar for component in component_combination]
        )
        interpolation_quantities = [
            # Particle components
            ('particles', [
                component.mass*a**(-3*component.w_eff(a=a))
                for component in component_combination]
            ),
            # Fluid components
            ('œ±', [
                (boxsize/component.gridsize)**3*a**(-3*component.w_eff(a=a))
                for component in component_combination]
            ),
        ]
        œÜ_dict = CIC_components2œÜ(list(component_combination), interpolation_quantities)
        # Flags specifying whether any
        # fluid/particle components are present.
        any_particles = ('particles' in œÜ_dict)
        any_fluid     = ('fluid'     in œÜ_dict)
        # Slab decompose the grids
        slab_dict = {
            representation: slab_decompose(œÜ, f'œÜ_{representation}_slab', prepare_fft=True)
            for representation, œÜ in œÜ_dict.items()
            }
        if any_fluid:
            slab_fluid = slab_dict['fluid']
        if any_particles:
            slab_particles = slab_dict['particles']
        # Do a forward in-place Fourier transform of the slabs
        for slab in slab_dict.values():
            fft(slab, 'forward')
            size_j, size_i, size_k = slab.shape[0], slab.shape[1], slab.shape[2]
        # Flag specifying whether or not n_modes has been computed
        fill_n_modes = (n_modes_fine[0] == -1)
        if fill_n_modes:
            n_modes_fine[0] = 0
        # Begin loop over slabs. As the first and second dimensions
        # are transposed due to the FFT, start with the j-dimension.
        nyquist = œÜ_gridsize//2
        for j in range(size_j):
            # The j-component of the wave vector (grid units).
            # Since the slabs are distributed along the j-dimension,
            # an offset must be used.
            j_global = ‚Ñ§[size_j*rank] + j
            if j_global > ‚Ñ§[œÜ_gridsize//2]:
                kj = j_global - œÜ_gridsize
            else:
                kj = j_global
            kj2 = kj**2
            # Reciprocal square root of the
            # j-component of the deconvolution.
            with unswitch(1):
                if any_particles:
                    reciprocal_sqrt_deconv_j = sinc(kj*‚Ñù[œÄ/œÜ_gridsize])
            # Loop over the entire first dimension
            for i in range(œÜ_gridsize):
                # The i-component of the wave vector
                if i > ‚Ñ§[œÜ_gridsize//2]:
                    ki = i - œÜ_gridsize
                else:
                    ki = i
                # Reciprocal square root of the product of the i-
                # and the j-component of the deconvolution.
                with unswitch(2):
                    if any_particles:
                        reciprocal_sqrt_deconv_ij = (
                            sinc(ki*‚Ñù[œÄ/œÜ_gridsize])*reciprocal_sqrt_deconv_j
                        )
                # Loop over the entire last dimension in steps of two,
                # as contiguous pairs of elements are the real and
                # imaginary part of the same complex number.
                for k in range(0, size_k, 2):
                    # The k-component of the wave vector
                    kk = k//2
                    # The squared magnitude of the wave vector
                    k2 = ‚Ñ§[ki**2 + kj2] + kk**2
                    # Skip the DC component.
                    # For some reason, the k = k_max mode is
                    # highly uncertain. Skip this as well.
                    if k2 == 0 or k2 == k2_max:
                        continue
                    # Get the bin index of this k¬≤
                    k_bin_index = k_bin_indices[k2]
                    # Do the CIC deconvolution of the particles slab
                    with unswitch(3):
                        if any_particles:
                            # Pointer to the [j, i, k]'th element of the
                            # particles slab.
                            # The complex number is then given as
                            # Re = slab_particles_jik[0],
                            # Im = slab_particles_jik[1].
                            slab_particles_jik = cython.address(slab_particles[j, i, k:])
                            # Reciprocal square root of the product of
                            # all components of the deconvolution.
                            reciprocal_sqrt_deconv_ijk = (
                                reciprocal_sqrt_deconv_ij*sinc(kk*‚Ñù[œÄ/œÜ_gridsize])
                            )
                            # The total factor
                            # for a complete deconvolution.
                            deconv_ijk = 1/reciprocal_sqrt_deconv_ijk**2
                            # Carry out the deconvolution
                            slab_particles_jik[0] *= deconv_ijk  # Real part
                            slab_particles_jik[1] *= deconv_ijk  # Imag part
                    # Get the total power of the [j, i, k]'th
                    # element of the slabs.
                    with unswitch(3):
                        if any_particles and any_fluid:
                            # Pointers to the [j, i, k]'th element of
                            # the particles and the fluid slab.
                            # The complex numbers are then given as e.g.
                            # Re = slab_particles_jik[0],
                            # Im = slab_particles_jik[1].
                            slab_particles_jik = cython.address(slab_particles[j, i, k:])
                            slab_fluid_jik     = cython.address(slab_fluid    [j, i, k:])
                            power_jik = (
                                  (slab_particles_jik[0] + slab_fluid_jik[0])**2
                                + (slab_particles_jik[1] + slab_fluid_jik[1])**2
                            )
                        elif any_particles:
                            # Pointer to the [j, i, k]'th element of the
                            # particles slab.
                            # The complex number is then given as
                            # Re = slab_particles_jik[0],
                            # Im = slab_particles_jik[1].
                            slab_particles_jik = cython.address(slab_particles[j, i, k:])
                            power_jik = slab_particles_jik[0]**2 + slab_particles_jik[1]**2
                        elif any_fluid:
                            # Pointer to the [j, i, k]'th element of the
                            # fluid slab.
                            # The complex number is then given as
                            # Re = slab_fluid_jik[0],
                            # Im = slab_fluid_jik[1].
                            slab_fluid_jik = cython.address(slab_fluid[j, i, k:])
                            power_jik = slab_fluid_jik[0]**2 + slab_fluid_jik[1]**2
                    # Because of the complex-conjugate symmetry,
                    # the slabs only contain the half with
                    # positive kk frequencies. Including this
                    # missing half lead to truer statistics,
                    # altering the binned power spectrum.
                    # Below, the symmetry_multiplicity
                    # variable counts the number of times this
                    # grid point should be counted.
                    if kk == 0 or kk == nyquist:
                        symmetry_multiplicity = 1
                    else:
                        symmetry_multiplicity = 2
                    # If the number of modes in each k¬≤ has not
                    # been tallied up yet, do this now.
                    with unswitch(3):
                        if fill_n_modes:
                            # Increase the multiplicity
                            # of this specific k2.
                            n_modes_fine[k2] += symmetry_multiplicity
                    # Increase the power in this bin.
                    # For now, power holds the sum of powers.
                    power[k_bin_index] += symmetry_multiplicity*power_jik
        # Sum power into the master process
        Reduce(
            sendbuf=(MPI.IN_PLACE if master else power),
            recvbuf=(power        if master else None),
            op=MPI.SUM,
        )
        # If n_modes_fine has just been tallied up,
        # construct n_modes and adjust k_bin_centers.
        if fill_n_modes:
            # Sum n_modes_fine into the master process
            Reduce(
                sendbuf=(MPI.IN_PLACE if master else n_modes_fine),
                recvbuf=(n_modes_fine if master else None),
                op=MPI.SUM,
            )
            # The master process now holds all the information needed.
            # Also, the slave processes are no longer in need
            # of the n_modes_fine array.
            if not master:
                n_modes_fine = zeros(1, dtype=C2np['Py_ssize_t'])
                continue
            # Redefine k_bin_centers so that each element is the mean of
            # all the k values that falls within the bin, using the
            # multiplicity (n_modes_fine) as weight. As a side product
            # we also construct n_modes from n_modes_fine.
            # Lastly, we store the maximum value of n_modes as its last
            # (extra) element, as it is used for formatting the output.
            k_bin_centers[:] = 0
            for k2 in range(1, n_modes_fine.shape[0]):
                if ‚Ñ§[n_modes_fine[k2]] == 0:
                    continue
                k_magnitude = ‚Ñù[2*œÄ/boxsize]*sqrt(k2)
                k_bin_index = k_bin_indices[k2]
                n_modes[k_bin_index] += ‚Ñ§[n_modes_fine[k2]]
                k_bin_centers[k_bin_index] += ‚Ñ§[n_modes_fine[k2]]*k_magnitude
            max_n_modes = 0
            for k_bin_index in range(k_bin_centers.shape[0]):
                if ‚Ñ§[n_modes[k_bin_index]] > 0:
                    k_bin_centers[k_bin_index] /= ‚Ñ§[n_modes[k_bin_index]]
                    if ‚Ñ§[n_modes[k_bin_index]] > max_n_modes:
                        max_n_modes = ‚Ñ§[n_modes[k_bin_index]]
            n_modes[n_modes.shape[0] - 1] = max_n_modes
            # The master process now also no longer need n_modes_fine
            n_modes_fine = zeros(1, dtype=C2np['Py_ssize_t'])
        # The master process now holds all the information needed
        if not master:
            continue
        # Find the index of the largest populated mode. It is either
        # n_modes.shape[0] - 2 or n_modes.shape[0] - 3.
        for i in range(n_modes.shape[0] - 2, -1, -1):
            if n_modes[i] != 0:
                index_largest_mode = i
                break
        # We need to transform power from being the sum to being the
        # mean, by dividing by n_modes.
        # We want to normalize the power spectrum with respect to the
        # box volume. Since we interpolated the mass to the grid and
        # then square each grid value to compute the power,
        # the normalization will be boxsize**3/Œ£mass**2.
        for i in range(‚Ñ§[index_largest_mode + 1]):
            power[i] *= ‚Ñù[boxsize**3/Œ£mass**2]/n_modes[i]
        # Compute the rms density variation œÉ_R_tophat (usually œÉ‚Çà).
        # This is given by
        # œÉ¬≤ = ‚à´d¬≥k/(2œÄ)¬≥ W¬≤ power
        #    = 1/(2œÄ)¬≥‚à´_0^‚àû dk 4œÄk¬≤ W¬≤ power
        #    = 1/(2œÄ¬≤)‚à´_0^‚àû dk k¬≤ W¬≤ power,
        # where W = 3(sin(kR) - kR*cos(kR))/(kR)¬≥.
        # Note that below, the factor 3¬≤ = 9 has been moved
        # outside of the integral (loop), and so W is really W/3.
        for i in range(‚Ñ§[index_largest_mode + 1]):
            k_magnitude = k_bin_centers[i]
            kR = k_magnitude*R_tophat
            if kR < 1e-3:
                # In the limit of vanishing kR, W/3 tends to 1/3
                W = ‚Ñù[1/3]
            else:
                W = (sin(kR) - kR*cos(kR))/kR**3
            œÉ2_integrand[i] = (k_magnitude*W)**2*power[i]
        # The integrand above starts from k = k_min, which means that
        # the interval from 0 to k_min has been left out. At k = 0,
        # the integrand vanishes. According to the trapezoidal rule,
        # this means that the full integral is missing the area of the
        # triangle with vertices (0, 0), (k_min, 0),
        # (k_min, œÉ2_integrand[0]), with k_min = k_bin_centers[0].
        œÉ_dict[component_combination] = np.sqrt(
            ‚Ñù[9/(2*œÄ**2)]*(  np.trapz(œÉ2_integrand [:‚Ñ§[index_largest_mode + 1]],
                                      k_bin_centers[:‚Ñ§[index_largest_mode + 1]])
                           + 0.5*k_bin_centers[0]*œÉ2_integrand[0]
                           )
            )
        # Done computing this power spectrum and its
        # associated rms density variation.
        masterprint('done')
    # If no power spectra has been computed, return now
    if not power_dict:
        return
    # Only the master process should write
    # power spectra to disk and do plotting.
    if not master:
        return
    # Trim the arrays inside power_dict so that they stop
    # at the largest populated mode.
    power_dict = {key: arr[:‚Ñ§[index_largest_mode + 1]] for key, arr in power_dict.items()}
    # Regardless of the values in powerspec_data_select, all power
    # spectra are saved. The exception is when nothing should be saved,
    # in which case we really do not save anything.
    if save_powerspecs:
        # We want to save all power spectra to a single text file.
        # First we generate the header.
        spectrum_plural = 'spectrum' if len(power_dict) == 1 else 'spectra'
        masterprint(f'Saving power {spectrum_plural} to "{filename}" ...')
        # The top line of the header, stating general information
        topline = [
            f'Power {spectrum_plural} from COùòïCEPT job {jobid} '
            f'at t = {universals.t:.6g} {unit_time}, '
        ]
        if enable_Hubble:
            topline += [f'a = {a:.6g}, ']
        topline += [f'computed with a grid of linear size {œÜ_gridsize}.']
        # A column mapping each component to a number
        component_index = 0
        component_mapping = collections.OrderedDict()
        for component_combination in power_dict.keys():
            for component in component_combination:
                if component not in component_mapping:
                    component_mapping[component] = component_index
                    component_index += 1
        longest_name_size = np.max([len(component.name) for component in component_mapping])
        column_components = ['Below, the following component mapping is used:']
        for component, component_index in component_mapping.items():
            column_components.append(f'  {{:<{longest_name_size + 1}}} {component_index}'
                                     .format(component.name + ':')
                                     )
        # A row of component specifications
        row_components = ['', '']
        for component_combination in power_dict.keys():
            component_indices_str = get_integerset_strrep([component_mapping[component]
                                                           for component in component_combination])
            if len(component_combination) == 1:
                row_components.append(f'component {component_indices_str}')
            else:
                row_components.append(f'components {{{component_indices_str}}}')
        # A row of œÉ (rms density variation) values
        œÉ_unit = units.Mpc/(H0/(100*units.km/(units.s*units.Mpc))) if enable_Hubble else units.Mpc
        œÉ_str = ''.join([
            unicode('œÉ'),
            unicode_subscript(f'{R_tophat/œÉ_unit:.3g}'),
            ' = {:.6g}',
        ])
        row_œÉ = ['', '', *[œÉ_str.format(œÉ) for œÉ in œÉ_dict.values()]]
        # A row of column headings
        row_headings = [# Note: The extra spaces are used to counteract the inserted "# "
                        unicode(f'k [{unit_length}‚Åª¬π]  '),
                        'modes',
                        *[unicode(f'power [{unit_length}¬≥]')]*len(power_dict),
                        ]
        # Adjust rows based on the column widths
        max_n_modes = n_modes[n_modes.shape[0] - 1]
        column_width_normal = len(f'{0:.16e}')
        column_widths = [# k [Mpc‚Åª¬π]
                         np.max([column_width_normal - 2, len(row_headings[0])]),
                         # n_modes
                         np.max([len(str(max_n_modes)), len(row_headings[1])]),
                         # power [Mpc‚Åª¬≥]
                         *[np.max([column_width_normal,
                                   len(row_components[i]),
                                   len(row_headings  [i]),
                                   len(row_œÉ         [i]),
                                   ])
                           for i in range(2, 2 + len(power_dict))],
                         ]
        for i in range(len(row_components)):
            row_components[i] = f'{{:^{column_widths[i]}}}'.format(row_components[i])
            row_œÉ         [i] = f'{{:^{column_widths[i]}}}'.format(row_œÉ         [i])
            row_headings  [i] = f'{{:^{column_widths[i]}}}'.format(row_headings  [i])
        # Assemble the header from its pieces
        delimiter = '  '
        header = [unicode(line) for line in [
            ''.join(topline),
            *column_components,
            '',
            delimiter.join(row_components),
            delimiter.join(row_œÉ),
            delimiter.join(row_headings),
        ]]
        # Save header and power spectra data to text file
        fmt = [f'%-{column_width}{"u" if i == 1 else ".16e"}'
               for i, column_width in enumerate(column_widths)]
        np.savetxt(
            filename,
            asarray([
                k_bin_centers[:‚Ñ§[index_largest_mode + 1]],
                n_modes      [:‚Ñ§[index_largest_mode + 1]],
                *power_dict.values(),
                ]).transpose(),
            fmt=fmt,
            delimiter=delimiter,
            header='\n'.join(header),
            )
        masterprint('done')
    # Plot the power spectra
    plot_powerspec(
        k_bin_centers[:‚Ñ§[index_largest_mode + 1]],
        power_dict,
        filename,
        powerspec_plot_select,
    )
# Initialize variables used for the power spectrum computation
# at import time, if such computation should ever take place.
cython.declare(
    i='Py_ssize_t',
    k_bin_center='double',
    k_bin_centers='double[::1]',
    k_bin_centers_size='Py_ssize_t',
    k_bin_indices='Py_ssize_t[::1]',
    k_bin_size='double',
    k_max='double',
    k_min='double',
    k_magnitude='double',
    k2='Py_ssize_t',
    k2_max='Py_ssize_t',
    n_modes='Py_ssize_t[::1]',
    n_modes_fine='Py_ssize_t[::1]',
    powerspec_data_select=dict,
    powerspec_plot_select=dict,
    œÉ2_integrand='double[::1]',
)
if any(powerspec_times.values()) or special_params.get('special') == 'powerspec':
    # Construct the powerspec_data_select and powerspec_plot_select
    # dicts from the powerspec_select parameter.
    powerspec_data_select = {key: val['data'] for key, val in powerspec_select.items()}
    powerspec_plot_select = {key: val['plot'] for key, val in powerspec_select.items()}
    # Maximum value of k¬≤ (grid units)
    k2_max = 3*(œÜ_gridsize//2)**2
    # Maximum and minum k values
    k_min = ‚Ñù[2*œÄ/boxsize]
    k_max = ‚Ñù[2*œÄ/boxsize]*sqrt(k2_max)
    # Construct linear k bins, each with a size of k_min.
    # Note that k_bin_centers will be changed later according to the
    # k¬≤ values on the 3D grid that falls inside each bin. The final
    # placing of the bin centers are then really defined indirectly by
    # k_bin_indices below (which depend on the initial values
    # given to k_bin_centers).
    k_bin_size = k_min
    k_bin_centers = np.arange(
        k_min + (0.5 - 1e+1*machine_œµ)*k_bin_size,
        k_max + k_bin_size,
        k_bin_size,
    )
    k_bin_centers_size = k_bin_centers.shape[0]
    # Construct array mapping k2 (grid units) to bin index
    k_bin_indices = empty(k2_max + 1, dtype=C2np['Py_ssize_t'])
    k_bin_indices[0] = 0
    i = 1
    for k2 in range(1, k_bin_indices.shape[0]):
        k_magnitude = ‚Ñù[2*œÄ/boxsize]*sqrt(k2)
        # Find index of closest bin center
        for i in range(i, k_bin_centers_size):
            k_bin_center = k_bin_centers[i]
            if k_bin_center > k_magnitude:
                # k2 belongs to either bin (i - 1) or bin i
                if k_magnitude - k_bin_centers[‚Ñ§[i - 1]] < k_bin_center - k_magnitude:
                    k_bin_indices[k2] = ‚Ñ§[i - 1]
                else:
                    k_bin_indices[k2] = i
                break
    # For the slave processes, the k_bin_centers are only used
    # above to define the k_bin_indices.
    if not master:
        k_bin_centers = None
    # Array counting the multiplicity (number of modes) of each
    # k¬≤ in the 3D grid.
    n_modes_fine = zeros(k_bin_indices.shape[0], dtype=C2np['Py_ssize_t'])
    # The multiplicity of each k¬≤ value is the same for all components
    # and constant throughout time. We therefore only need to compute
    # this once. Flag the first element so that we know it has not
    # been computed yet.
    n_modes_fine[0] = -1
    # Once the power spectrum has been collectively computed, it is up
    # to the master process to store and/or plot it.
    # For this, additional arrays are needed.
    if master:
        # Like n_modes_fine, but counting the multiplicity of the bins,
        # rather than the individual k¬≤ elements.
        # One additional element is allocated, which will be used to
        # store the largest of all the other multiplicities.
        n_modes = zeros(k_bin_centers_size + 1, dtype=C2np['Py_ssize_t'])
        # Array used for storing the integrand of œÉ¬≤,
        # the squared rms density variation œÉ_R_tophat (usually œÉ‚Çà).
        œÉ2_integrand = empty(k_bin_centers_size, dtype=C2np['double'])

# Function which can measure different quantities of a passed component
@cython.header(
    # Arguments
    component='Component',
    quantity=str,
    # Locals
    J_arr=object, # np.ndarray
    J_noghosts='double[:, :, :]',
    N='Py_ssize_t',
    N_elements='Py_ssize_t',
    Vcell='double',
    a='double',
    diff_backward='double[:, :, ::1]',
    diff_forward='double[:, :, ::1]',
    diff_max='double[::1]',
    diff_max_dim='double',
    diff_size='double',
    dim='int',
    fluidscalar='FluidScalar',
    h='double',
    i='Py_ssize_t',
    j='Py_ssize_t',
    k='Py_ssize_t',
    mom='double*',
    mom2='double',
    mom2_max='double',
    mom2_i='double',
    momx='double*',
    momy='double*',
    momz='double*',
    mom_i='double',
    names=list,
    t='double',
    v_rms='double',
    v_max='double',
    w='double',
    w_eff='double',
    Œîdiff='double',
    Œîdiff_max='double[::1]',
    Œîdiff_max_dim='double',
    Œîdiff_max_list=list,
    Œîdiff_max_normalized_list=list,
    J_over_œ±_plus_ùí´_2_i='double',
    J_over_œ±_plus_ùí´_2_max='double',
    J_over_œ±_2_i='double',
    J_over_œ±_2_max='double',
    Jx_mv='double[:, :, ::1]',
    Jx_ptr='double*',
    Jy_mv='double[:, :, ::1]',
    Jy_ptr='double*',
    Jz_mv='double[:, :, ::1]',
    Jz_ptr='double*',
    Œ£J_over_œ±_plus_ùí´_2='double',
    Œ£mass='double',
    Œ£mom='double[::1]',
    Œ£mom_dim='double',
    Œ£mom2_dim='double',
    Œ£œ±='double',
    Œ£œ±2='double',
    œ±='FluidScalar',
    œ±_arr=object,  # np.ndarray
    œ±_bar='double',
    œ±_min='double',
    œ±_mv='double[:, :, ::1]',
    œ±_noghosts='double[:, :, :]',
    œ±_ptr='double*',
    œÉ2mom_dim='double',
    œÉ2œ±='double',
    œÉmom='double[::1]',
    œÉmom_dim='double',
    œÉœ±='double',
    ùí´_mv='double[:, :, ::1]',
    ùí´_ptr='double*',
    returns=object,  # double or tuple
)
def measure(component, quantity):
    """Implemented quantities are:
    'v_max'
    'v_rms'
    'momentum'
    'œ±'              (fluid quantity)
    'mass'           (fluid quantity)
    'discontinuity'  (fluid quantity)
    """
    t = universals.t
    a = universals.a
    # Extract variables
    N = component.N
    N_elements = component.gridsize**3
    Vcell = boxsize**3/N_elements
    w     = component.w    (a=a)
    w_eff = component.w_eff(a=a)
    œ± = component.œ±
    œ±_noghosts = œ±.grid_noghosts
    # Quantities exhibited by both particle and fluid components
    if quantity == 'v_max':
        # The propagation speed of information in
        # comoving coordinates is
        # v = c*sqrt(w)/a + ·∫ã, ·∫ã = dx/dt = u/a,
        # where u is the peculiar velocity.
        # For fluids we have
        # œ± = a**(3*(1 + w_eff))œÅ, J = a**4*(œÅ + c‚Åª¬≤P)u,
        # and so
        # u = a**(-4)*J/(œÅ + c‚Åª¬≤P)
        #   = a**(3*w_eff - 1)*J/(œ± + c‚Åª¬≤ùí´),
        # and then
        # v = c*sqrt(w)/a + a**(3*w_eff - 2)*J/(œ± + c‚Åª¬≤ùí´),
        # where c*sqrt(w) is an approximation for the local sound speed.
        # For particles we have w = 0 and ·∫ã = mom/(a**2*m), and so
        # v = mom/(a**2*mass).
        # In the case of decyaing (matter) particles, the mass at time a
        # is really a**(-3*w_eff)*mass, and so we get
        # v = mom/(a**(2 - 3*w_eff)*mass)
        if component.representation == 'particles':
            mom2_max = 0
            momx = component.momx
            momy = component.momy
            momz = component.momz
            for i in range(component.N_local):
                mom2_i = momx[i]**2 + momy[i]**2 + momz[i]**2
                if mom2_i > mom2_max:
                    mom2_max = mom2_i
            mom2_max = allreduce(mom2_max, op=MPI.MAX)
            v_max = sqrt(mom2_max)/(a**(2 - 3*w_eff)*component.mass)
        elif component.representation == 'fluid':
            if (    component.boltzmann_order == -1
                or (component.boltzmann_order == 0 and component.boltzmann_closure == 'truncate')
                ):
                # Without J as a fluid variable,
                # no explicit velocity exists.
                v_max = 0
            elif component.boltzmann_order == 0 and component.boltzmann_closure == 'class':
                # With J as a linear fluid variable, we only need to
                # consider one of its components. Also, the P = wœÅ
                # approximation is guaranteed to be enabled.
                œ±_ptr  = component.œ± .grid
                Jx_ptr = component.Jx.grid
                J_over_œ±_2_max = 0
                for i in range(component.size):
                    J_over_œ±_2_i = (Jx_ptr[i]/œ±_ptr[i])**2
                    if J_over_œ±_2_i > J_over_œ±_2_max:
                        J_over_œ±_2_max = J_over_œ±_2_i
                J_over_œ±_2_max = allreduce(J_over_œ±_2_max, op=MPI.MAX)
                J_over_œ±_plus_ùí´_2_max = 3*J_over_œ±_2_max/(1 + w)**2
                v_max = a**(3*w_eff - 2)*sqrt(J_over_œ±_plus_ùí´_2_max)
                # Since no non-linear evolution happens for J, the Euler
                # equation and hence the gradient of the pressure will
                # never be computed. This means that sound waves
                # cannot form, and so we do not need to take the sound
                # speed into account.
            else:
                # J is non-linear
                œ±_ptr  = component.œ± .grid
                ùí´_ptr  = component.ùí´ .grid
                Jx_ptr = component.Jx.grid
                Jy_ptr = component.Jy.grid
                Jz_ptr = component.Jz.grid
                J_over_œ±_plus_ùí´_2_max = 0
                for i in range(component.size):
                    J_over_œ±_plus_ùí´_2_i = (
                        (Jx_ptr[i]**2 + Jy_ptr[i]**2 + Jz_ptr[i]**2)
                        /(œ±_ptr[i] + ‚Ñù[light_speed**(-2)]*ùí´_ptr[i])**2
                    )
                    if J_over_œ±_plus_ùí´_2_i > J_over_œ±_plus_ùí´_2_max:
                        J_over_œ±_plus_ùí´_2_max = J_over_œ±_plus_ùí´_2_i
                J_over_œ±_plus_ùí´_2_max = allreduce(J_over_œ±_plus_ùí´_2_max, op=MPI.MAX)
                v_max = a**(3*w_eff - 2)*sqrt(J_over_œ±_plus_ùí´_2_max)
                # Add the sound speed. When the P=wœÅ approxiamation is
                # False, the sound speed is non-global and given by the
                # square root of Œ¥ùí´/Œ¥œ±. However, constructing Œ¥ùí´/Œ¥œ±
                # locally from the œ± and ùí´ grids leads to large
                # numerical errors. Regardless of whether the P=wœÅ
                # approximation is used or not, we simply use the
                # global sound speed.
                v_max += light_speed*sqrt(w)/a
        return v_max
    elif quantity == 'v_rms':
        if component.representation == 'particles':
            mom2 = 0
            momx = component.momx
            momy = component.momy
            momz = component.momz
            for i in range(component.N_local):
                mom2 += momx[i]**2 + momy[i]**2 + momz[i]**2
            mom2 = allreduce(mom2, op=MPI.SUM)
            v_rms = sqrt(mom2/component.N)/(a**(2 - 3*component.w_eff(a=a))*component.mass)
        elif component.representation == 'fluid':
            if (    component.boltzmann_order == -1
                or (component.boltzmann_order == 0 and component.boltzmann_closure == 'truncate')
                ):
                # Without J as a fluid variable, no velocity exists
                v_rms = 0
            elif component.boltzmann_order == 0 and component.boltzmann_closure == 'class':
                # With J as a linear fluid variable, we only need to
                # consider one of its components. Also, the P = wœÅ
                # approximation is guaranteed to be enabled.
                œ±_mv  = component.œ± .grid_mv
                Jx_mv = component.Jx.grid_mv
                Œ£J_over_œ±_plus_ùí´_2 = 0
                for         i in range(2, ‚Ñ§[component.shape[0] - 2 - 1]):
                    for     j in range(2, ‚Ñ§[component.shape[1] - 2 - 1]):
                        for k in range(2, ‚Ñ§[component.shape[2] - 2 - 1]):
                            Œ£J_over_œ±_plus_ùí´_2 += 3*(Jx_mv[i, j, k]/(œ±_mv[i, j, k]*(1 + w)))**2
                Œ£J_over_œ±_plus_ùí´_2 = allreduce(Œ£J_over_œ±_plus_ùí´_2, op=MPI.SUM)
                v_rms = a**(3*w_eff - 2)*sqrt(Œ£J_over_œ±_plus_ùí´_2/N_elements)
                # Since no non-linear evolution happens for J, the Euler
                # equation and hence the gradient of the pressure will
                # never be computed. This means that sound waves
                # cannot form, and so we do not need to take the sound
                # speed into account.
            else:
                # J is non-linear
                œ±_mv  = component.œ± .grid_mv
                ùí´_mv  = component.ùí´ .grid_mv
                Jx_mv = component.Jx.grid_mv
                Jy_mv = component.Jy.grid_mv
                Jz_mv = component.Jz.grid_mv
                Œ£J_over_œ±_plus_ùí´_2 = 0
                for         i in range(2, ‚Ñ§[component.shape[0] - 2 - 1]):
                    for     j in range(2, ‚Ñ§[component.shape[1] - 2 - 1]):
                        for k in range(2, ‚Ñ§[component.shape[2] - 2 - 1]):
                            Œ£J_over_œ±_plus_ùí´_2 += (
                                (Jx_mv[i, j, k]**2 + Jy_mv[i, j, k]**2 + Jz_mv[i, j, k]**2)
                                /(œ±_mv[i, j, k] + ‚Ñù[light_speed**(-2)]*ùí´_mv[i, j, k])**2
                            )
                Œ£J_over_œ±_plus_ùí´_2 = allreduce(Œ£J_over_œ±_plus_ùí´_2, op=MPI.SUM)
                v_rms = a**(3*w_eff - 2)*sqrt(Œ£J_over_œ±_plus_ùí´_2/N_elements)
                # Add the sound speed. When the P=wœÅ approxiamation is
                # False, the sound speed is non-global and given by the
                # square root of Œ¥ùí´/Œ¥œ±. However, constructing Œ¥ùí´/Œ¥œ±
                # locally from the œ± and ùí´ grids leads to large
                # numerical errors. Regardless of whether the P=wœÅ
                # approximation is used or not, we simply use the
                # global sound speed.
                v_rms += light_speed*sqrt(w)/a
        return v_rms
    elif quantity == 'momentum':
        Œ£mom = empty(3, dtype=C2np['double'])
        œÉmom = empty(3, dtype=C2np['double'])
        if component.representation == 'particles':
            # Total momentum of all particles, for each dimension
            for dim in range(3):
                mom = component.mom[dim]
                Œ£mom_dim = Œ£mom2_dim = 0
                # Add up local particle momenta
                for i in range(component.N_local):
                    mom_i = mom[i]
                    Œ£mom_dim  += mom_i
                    Œ£mom2_dim += mom_i**2
                # Add up local particle momenta sums
                Œ£mom_dim  = allreduce(Œ£mom_dim,  op=MPI.SUM)
                Œ£mom2_dim = allreduce(Œ£mom2_dim, op=MPI.SUM)
                # Compute global standard deviation
                œÉ2mom_dim = Œ£mom2_dim/N - (Œ£mom_dim/N)**2
                if œÉ2mom_dim < 0:
                    # Negative (about -machine_œµ) œÉ¬≤ can happen due
                    # to round-off errors.
                    œÉ2mom_dim = 0
                œÉmom_dim = sqrt(œÉ2mom_dim)
                # Pack results
                Œ£mom[dim] = Œ£mom_dim
                œÉmom[dim] = œÉmom_dim
        elif component.representation == 'fluid':
            # Total momentum of all fluid elements, for each dimension.
            # Here the definition of momenta is chosen as
            # J*Vcell = (a**4*(œÅ + c‚Åª¬≤P))*Vcell
            #         = (V_phys*(œÅ + c‚Åª¬≤P))*a*u,
            # which reduces to mass*a*u for pressureless fluids and so
            # it is in correspondance with the momentum definition
            # for particles.
            for dim, fluidscalar in enumerate(component.J):
                # NumPy array of local part of J with no pseudo points
                J_noghosts = fluidscalar.grid_noghosts
                J_arr = asarray(J_noghosts[:(J_noghosts.shape[0] - 1),
                                           :(J_noghosts.shape[1] - 1),
                                           :(J_noghosts.shape[2] - 1)])
                # Total dim'th momentum of all fluid elements
                Œ£mom_dim = np.sum(J_arr)*Vcell
                # Total dim'th momentum squared of all fluid elements
                Œ£mom2_dim = np.sum(J_arr**2)*Vcell**2
                # Add up local fluid element momenta sums
                Œ£mom_dim  = allreduce(Œ£mom_dim,  op=MPI.SUM)
                Œ£mom2_dim = allreduce(Œ£mom2_dim, op=MPI.SUM)
                # Compute global standard deviation
                œÉ2mom_dim = Œ£mom2_dim/N_elements - (Œ£mom_dim/N_elements)**2
                if œÉ2mom_dim < 0:
                    # Negative (about -machine_œµ) œÉ¬≤ can happen due
                    # to round-off errors.
                    œÉ2mom_dim = 0
                œÉmom_dim = sqrt(œÉ2mom_dim)
                # Pack results
                Œ£mom[dim] = Œ£mom_dim
                œÉmom[dim] = œÉmom_dim
        return Œ£mom, œÉmom
    # Fluid quantities
    elif quantity == 'œ±':
        # Compute mean(œ±), std(œ±), min(œ±)
        if component.representation == 'particles':
            # Particle components have no œ±
            abort('The measure function was called with the "{}" component with '
                  'quantity=\'œ±\', but particle components do not have œ±.'
                  .format(component.name)
                  )
        elif component.representation == 'fluid':
            # NumPy array of local part of œ± with no pseudo points
            œ±_arr = asarray(œ±_noghosts[:(œ±_noghosts.shape[0] - 1),
                                       :(œ±_noghosts.shape[1] - 1),
                                       :(œ±_noghosts.shape[2] - 1)])
            # Total œ± of all fluid elements
            Œ£œ± = np.sum(œ±_arr)
            # Total œ±¬≤ of all fluid elements
            Œ£œ±2 = np.sum(œ±_arr**2)
            # Add up local sums
            Œ£œ±  = allreduce(Œ£œ±,  op=MPI.SUM)
            Œ£œ±2 = allreduce(Œ£œ±2, op=MPI.SUM)
            # Compute mean value of œ±
            œ±_bar = Œ£œ±/N_elements
            # Compute global standard deviation
            œÉ2œ± = Œ£œ±2/N_elements - œ±_bar**2
            if œÉ2œ± < 0:
                # Negative (about -machine_œµ) œÉ¬≤ can happen due
                # to round-off errors.
                œÉ2œ± = 0
            œÉœ± = sqrt(œÉ2œ±)
            # Compute minimum value of œ±
            œ±_min = allreduce(np.min(œ±_arr), op=MPI.MIN)
        return œ±_bar, œÉœ±, œ±_min
    elif quantity == 'mass':
        if component.representation == 'particles':
            # Any change in the mass of particle a component is absorbed
            # into w_eff(a).
            Œ£mass = a**(-3*w_eff)*component.N*component.mass
        elif component.representation == 'fluid':
            # NumPy array of local part of œ± with no pseudo points
            œ±_arr = asarray(œ±_noghosts[:(œ±_noghosts.shape[0] - 1),
                                       :(œ±_noghosts.shape[1] - 1),
                                       :(œ±_noghosts.shape[2] - 1)])
            # Total œ± of all fluid elements
            Œ£œ± = np.sum(œ±_arr)
            # Add up local sums
            Œ£œ± = allreduce(Œ£œ±, op=MPI.SUM)
            # The total mass is
            # Œ£mass = (a**3*Vcell)*Œ£œÅ
            # where a**3*Vcell is the proper volume and Œ£œÅ is the sum of
            # proper densities. In terms of the fluid variable
            # œ± = a**(3*(1 + w_eff))*œÅ, the total mass is then
            # Œ£mass = a**(-3*w_eff)*Vcell*Œ£œ±.
            # Note that the total mass is generally constant.
            Œ£mass = a**(-3*w_eff)*Vcell*Œ£œ±
        return Œ£mass
    elif quantity == 'discontinuity':
        if component.representation == 'particles':
            # Particle components have no discontinuity
            abort('The measure function was called with the "{}" component with '
                  'quantity=\'discontinuity\', which is not applicable to particle components.'
                  .format(component.name)
                  )
        elif component.representation == 'fluid':
            # Lists to store results which will be returned
            names = []
            Œîdiff_max_normalized_list = []
            Œîdiff_max_list = []
            # The grid spacing in physical units
            h = boxsize/component.gridsize
            # Find the maximum discontinuity in each fluid grid
            for fluidscalar in component.iterate_fluidscalars():
                # Store the name of the fluid scalar
                names.append(str(fluidscalar))
                # Communicate pseudo and ghost points of the grid
                communicate_domain(fluidscalar.grid_mv, mode='populate')
                # Differentiate the grid in all three directions via
                # both forward and backward difference. For each
                # direction, save the largest difference between
                # the two. Also save the largest differential in
                # each direction.
                Œîdiff_max = empty(3, dtype=C2np['double'])
                diff_max = empty(3, dtype=C2np['double'])
                for dim in range(3):
                    # Do the differentiations
                    diff_forward  = diff_domain(fluidscalar.grid_mv, dim, h, 0, order=1, direction='forward')
                    diff_backward = diff_domain(fluidscalar.grid_mv, dim, h, 1, order=1, direction='backward')
                    # Find the largest difference between the results of the
                    # forward and backward difference,
                    Œîdiff_max_dim = 0
                    diff_max_dim = 0
                    for         i in range(‚Ñ§[œ±_noghosts.shape[0] - 1]):
                        for     j in range(‚Ñ§[œ±_noghosts.shape[1] - 1]):
                            for k in range(‚Ñ§[œ±_noghosts.shape[2] - 1]):
                                # The maximum difference of the two differentials
                                Œîdiff = abs(diff_forward[i, j, k] - diff_backward[i, j, k])
                                if Œîdiff > Œîdiff_max_dim:
                                    Œîdiff_max_dim = Œîdiff
                                # The maximum differential
                                diff_size = abs(diff_forward[i, j, k])
                                if diff_size > diff_max_dim:
                                    diff_max_dim = diff_size
                                diff_size = abs(diff_backward[i, j, k])
                                if diff_size > diff_max_dim:
                                    diff_max_dim = diff_size
                    # Use the global maxima
                    Œîdiff_max_dim = allreduce(Œîdiff_max_dim, op=MPI.MAX)
                    diff_max_dim  = allreduce(diff_max_dim,  op=MPI.MAX)
                    # Pack results into lists
                    Œîdiff_max[dim] = Œîdiff_max_dim
                    diff_max[dim] = diff_max_dim
                Œîdiff_max_list.append(Œîdiff_max)
                # Maximum discontinuity (difference between forward and
                # backward difference) normalized accoring to
                # the largest slope.
                Œîdiff_max_normalized_list.append(np.array([Œîdiff_max[dim]/diff_max[dim]
                                                           if Œîdiff_max[dim] > 0 else 0
                                                           for dim in range(3)
                                                           ], dtype=C2np['double'],
                                                          )
                                                 )
        return names, Œîdiff_max_list, Œîdiff_max_normalized_list
    elif master:
        abort(
            f'The measure function was called with '
            f'quantity=\'{quantity}\', which is not implemented'
        )

# Function for doing debugging analysis
@cython.header(# Arguments
               components=list,
               # Locals
               component='Component',
               dim='int',
               name=str,
               w_eff='double',
               Œîdiff_max='double[::1]',
               Œîdiff_max_normalized='double[::1]',
               Œ£mom='double[::1]',
               Œ£mom_prev_dim='double',
               œ±_bar='double',
               œ±_min='double',
               œÉmom='double[::1]',
               œÉœ±='double',
               )
def debug(components):
    """This function will compute many different quantities from the
    component data and print out the results. Warnings will be given for
    obviously erroneous results.
    """
    # Componentwise analysis
    for component in components:
        w_eff = component.w_eff()
        # sum(momentum) and std(momentum) in each dimension
        Œ£mom, œÉmom = measure(component, 'momentum')
        for dim in range(3):
            debug_print('total {}-momentum'.format('xyz'[dim]),
                        component,
                        Œ£mom[dim],
                        'm‚òâ Mpc Gyr‚Åª¬π',
                        )
            debug_print('standard deviation of {}-momentum'.format('xyz'[dim]),
                        component,
                        œÉmom[dim],
                        'm‚òâ Mpc Gyr‚Åª¬π',
                        )
        # Warn if sum(momentum) does not agree with previous measurement
        if component.name in Œ£mom_prev:
            for dim in range(3):
                Œ£mom_prev_dim = Œ£mom_prev[component.name][dim]
                if not isclose(Œ£mom_prev_dim, Œ£mom[dim],
                               rel_tol=1e-6,
                               abs_tol=1e-6*œÉmom[dim],
                               ):
                    masterwarn('Previously the "{}" had a '
                               'total {}-momentum of {} m‚òâ Mpc Gyr‚Åª¬π'
                               .format(component.name,
                                       'xyz'[dim],
                                       significant_figures(Œ£mom_prev_dim
                                                           /(units.m_sun*units.Mpc/units.Gyr),
                                                           12,
                                                           fmt='unicode',
                                                           incl_zeros=False,
                                                           scientific=True,
                                                           ),
                                       )
                               )
        Œ£mom_prev[component.name] = asarray(Œ£mom).copy()
        # mean(œ±), std(œ±) and min(œ±)
        if component.representation == 'fluid':
            œ±_bar, œÉœ±, œ±_min = measure(component, 'œ±')
            debug_print('mean œ±',
                        component,
                        œ±_bar,
                        'm‚òâ Mpc‚Åª¬≥',
                        )
            debug_print('standard deviation of œ±',
                        component,
                        œÉœ±,
                        'm‚òâ Mpc‚Åª¬≥',
                        )
            debug_print('minimum œ±',
                        component,
                        œ±_min,
                        'm‚òâ Mpc‚Åª¬≥',
                        )
            # Warn if any densities are negative
            if œ±_min < 0:
                masterwarn('Negative density occured in "{}"'.format(component.name))
            # Warn if mean(œ±) differs from the correct, constant result
            if not isclose(œ±_bar, cast(component.œ±_bar, 'double'), rel_tol=1e-6):
                masterwarn('The "{}" ought to have a mean œ± of {} m‚òâ Mpc‚Åª¬≥'
                           .format(component.name,
                                   significant_figures(component.œ±_bar/(units.m_sun/units.Mpc**3),
                                                       12,
                                                       fmt='unicode',
                                                       incl_zeros=False,
                                                       scientific=True,
                                                       ),
                                   )
                    )
        # The maximum discontinuities in the fluid scalars,
        # for each dimension. Here, a discontinuity means a difference
        # in forward and backward difference.
        if component.representation == 'fluid':
            for name, Œîdiff_max, Œîdiff_max_normalized in zip(*measure(component, 'discontinuity')):
                for dim in range(3):
                    debug_print('maximum            {}-discontinuity in {}'.format('xyz'[dim], name),
                                component,
                                Œîdiff_max[dim],
                                'Mpc‚Åª¬π',
                                )
                    debug_print('maximum normalized {}-discontinuity in {}'.format('xyz'[dim], name),
                                component,
                                Œîdiff_max_normalized[dim],
                                )
# Dict storing sum of momenta for optained in previous call to the
# debug function, for all components.
cython.declare(Œ£mom_prev=dict)
Œ£mom_prev = {}

# Function for printing out debugging info,
# used in the debug function above.
@cython.header(# Arguments
               quantity=str,
               component='Component',
               value='double',
               unit_str=str,
               # Locals
               text=str,
               unit='double',
               value_str=str,
               )
def debug_print(quantity, component, value, unit_str='1'):
    unit = eval_unit(unit_str)
    value_str = significant_figures(value/unit,
                                    12,
                                    fmt='unicode',
                                    incl_zeros=False,
                                    scientific=True,
                                    )
    text = '{} {}({}) = {}{}'.format(terminal.bold_cyan('Debug info:'),
                                     quantity[0].upper() + quantity[1:],
                                     component.name,
                                     value_str,
                                     ' ' + unit_str if unit_str != '1' else '',
                                     )
    masterprint(text)
